// 시간복잡도
// = 알고리즘 선택의 기준
// = 주어진 문제를 해결하기 위한 연산 횟수
// (일반적으로 수행 시간은 1억번의 연산을 1초의 시간으로 간주하여 예측)

// ex) 시간제한 2초
// => 2억번의 연산 안에 답이 나와야 함

// 빅오메가: 최선일 때 연산횟수
// 빅세타: 보통일 때 연산횟수
// 빅오: 최악일 때 연산횟수 (이것을 항상 염두해둬야 함)

//Ex)
public class TimeComplex {
    public static void main(String[] args) {
        int findNumber = (int) (Math.random() * 100);
        for (int i = 0; i < 100; i++) {
            if (i == findNumber) {
                System.out.println();
                break;
            }
        }
    }
}

// 여기서
// 빅 오메가 = 1
// 빅 세타 = 50 (N/2)
// 빅오 = 99 (N-1)

// 빅오를 기준으로 수행시간을 계산

// 연산횟수 = 알고리즘 시간 복잡도 X 데이터의 크기

// 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출

// 이중 for문 => N^2의 시간복잡문

// 시간복잡도 줄이기 위한 Tip
// 1. 알맞은 알고리즘 쓰기
// 2. 비효율적인 로직 찾아서 효율적으로 바꾸기