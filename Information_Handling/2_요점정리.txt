 자료구조

1) 자료 구조의 분류
- Linear Structure
-- Array
-- Stack
-- Queue
-- Deque
-- Linear List : 연속 리스트(순차적임), 연결 리스트(순차적이지 않음)

- Non-Linear Structure
-- Tree
-- Graph


2) Array
- 정적인 자료 구조, 기억장소 추가 어려움, 메모리 낭비 발생
- 첨자 이용
- 반복적인 데이터 처리 작업
- 동일한 이름의 변수 사용

3) Stack
- LIFO: Last In First Out

4) Queue
- FIFO : First In First Out

5) Deque
- 리스트 양쪽 끝에서 삽입과 삭제작업

6) Linear List
- Contiguous List
-- 연속되는 기억장소에 저장
-- 기억장소 이용 효율 가장 좋음
-- 연속된 빈 공간
-- 삽입, 삭제 시 자료의 이동 필요

- Linked List
-- 노드의 포인터 부분을 이용해 서로 연결
-- 삽입, 삭제 작업 용이
-- 순차 리스트에 비해 효율 나쁨
-- 접근 속도 느림

7) Tree
- Node와 Branch를 이용해 사이클을 이루지 않도록 구성
-- Node : 기본 요소
-- Root Node : 트리의 맨 위에 있는 노드
-- Terminal Node : Degree가 0, 자식이 하나도 없는 노드
-- Son Node : 다음 레벨의 노드들
-- Parent Node : 이전 레벨의 노드들
-- Brother Node, Sibling : 동일한 부모를 갖는 노드들
-- Degree : 노드들의 디그리 중에서 가장 많은 수

8) Graph
- 방향 그래프
-- 방향이 있는 그래프
-- 최대 간선 수 = n(n - 1)

- 무방향 그래프
-- 방향이 없는 그래프
-- 최대 간선 수 = n(n - 1)/2



DBMS
1) Database
- Shared Data : 공동으로 소유하고 유지하는 자료
- Integrated Data : 중복을 최대로 배제
- Operational Data : 없어서는 안 됨
- Stored Data : 저장 매체에 저장 됨

2) Database Management System
- 정의 기능 : 정의, 이용방식, 제약 조건 명시 -> DDL
- 조작 기능 : 인터페이스 수단 제공 -> DML
- 제어 기능 : 무결성, 보안, 권한, 병행 제어 -> DCL



Data Input/Output
1) SQL (Structured Query Language)
- 데이터 정의어(DDL : Data Define Language) : 정의, 변경, 삭제
- 데이터 조작어(DML : Data Manipulation Language) : 데이터 직접 처리
- 데이터 제어어(DCL : Data Control Language) : 무결성, 보안, 회복, 병행 제어 정의

2) Data Mapping
- 코드와 DB의 데이터를 연결(Mapping)을 의미
- SQL Mapping : SQL 직접 입력하여 접속
-- ex) JDBC, ODBC, MyBatis
- ORM(Object-Relational Mapping) : 객체와 관게형 데이터 베이스(RDB)의 데이터를 연결
-- ex) JPA, Hiberate, Django

3) Transaction
- 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 한꺼번에 수행되어야 하는 일련의 연산들
-- COMMIT : 트랜잭션 처리가 정상적으로 종료 -> 변경 내용 DB에 반영
-- ROLLBACK :  트랜잭션 처리가 비정상적으로 종료 -> 모든 변경 작업 취소하고 이전상태로 롤백
-- SAVEPOINT(=CHECKPOINT) : ROLLBACK 할 저장점을 지정하는 명령어, 여러개 지정 가능
- 원리
- 원자성(Atomicity) : 모두에 반영하거나 반영하지 말아야 함 (All or Nothing)
- 일관성(Consistency) : 한 개의 트랜잭션만 접근 가능
- 영속성(Durability) : 영구적으로 반영됨



절차형 SQL
1) 개요
- 연속적인 실행이나, 분기, 반복 등의 제어가 가능한 SQL
- 프로그래밍 언어에 비해 효율이 떨어짐
- 연속적인 작업을 처리하는데 적합
- BEGIN ~ END 형식의 Block 구조로 기능별 모듈화 가능
-- 프로시저 (Procedure) : 미리 저장해 놓은 SQL 작업 수행, 한 개 이상의 값 혹인 반환을 아예 안함
-- Trigger : 입력, 갱신, 삭제 등의 이벤트 발생시 마다 관련 작업 자동 수행
-- 사용자 정의 함수 : 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환

2) Test & Debug
- 테스트 전 구문 오류(Syntax Error)나 참조 오류 존재 여부 확인
- SHOW 명령어를 통해 내용 확인
- SQL 문을 주석으로 처리하고 디버깅

3) 쿼리 성능 최적화
- 어플리케이션 성능 향상을 위해 SQL 코드 최적화
- 성능 측정도구 APM(Application Performance Management/Monitoring)을 사용해 최적화 할 쿼리를 선정
- 최적화할 커리에 대해 Optimizer가 수립한 실행 계혹 검토



개발 지원 도구
1) 통합 개발 환경(IDE : Integrated Development Environment)
- 다양한 툴을 하나의 인터페이스로 통합해 제공
-- 이클립스 : IBM
-- 비주얼 스튜디오 : Microsoft
-- 엑스 코드 : Apple
-- 안드로이드 스튜디오 : Google
-- IDEA : JetBrains

2) 빌드 자동화 도구
- 소스 코드 -> 소프트웨어 변환 과정에 필요한 작업을 수행하는 소프트웨어

- Ant(Another Neat Tool)
-- 아파치 소프트웨어 재단 개발
-- 자바 프로젝트의 공식적인 빌드 자동화 도구
-- XML 기반의 빌드 스크립트를 사용
-- 개발자가 모든 것을 정의
-- 재사용 어려움

- Maven
-- 아파치에서 만든 Ant의 대안
-- 컴파일과 빌드 동시 수행 가능
-- 의존성(Dependency)을 설정하여 라이브러리 관리

- Gradle
-- Ant와 maven을 보완해 개발
-- 안드로이드 스튜디오(안드로이드 앱 개발)
-- Dependency 활용
-- Groovy 기반
-- 명령을 모은 task 단위로 실행
-- 빌드 캐시 기능 지원

- Jenkins
-- Java 기반의 오픈 소스 형태
-- 서플릿 컨테이너에서 실행되는 서버 기반 도구
-- 대부분의 형상 관리 도구와 연동 가능
-- 친숙한 Web GUI 제공

3) 기타 협업 도구 (Groupware, 그룹웨어)
- 일정 관리 도구 : Goolge Calendar
- 프로젝트 관리 도구 : Trello, Jira
- 정보 공유 및 커뮤니케이션 도구 : Slack, Jandi, Task world
- 디자인 도구 : Sketch, Zeplin
- 아이디어 공유 도구 : Evernote
- 형상 관리 도구 : GitHub



소프트웨어 패키징
1) 개요
- 개발자가 아닌 사용자 중심 진행

2) 고려사항
- 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
- 다양한 사용자의 요구사항 반영

3) 패키징 작업 순서
- 기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 및 적용 시험 -> 패키징 변경 개선 -> 배포

4) 제품 소프트웨어 패키징 도구 활용 시 고려사항
- 보안
- 복잡성 및 비효율성
- 암호화 알고리즘
- 다양한 이기종 연동




Release Note
1) 개요
- 고객과 공유하기 위한 문서
- 개선된 작업이 있을 때마다 관련 내용을 담아 제공

2) 초기 버전 작성 시 고려사항
- Header : 릴리즈 노트 이름, 소프트 웨어 이름, 릴리즈 버전, 릴리즈 날짜, 노트 날짜, 노트 버전
- 개요 : 전체에 대한 간단한 내용
- 목적 : 새로운 기능 목록 및 노트의 목적
- 문제 요약 : 수정된 버그에 대한 설명 또는 추가 항목 요약
- 재현 항목 : 버그 발견에 대한 과정
- 수정/개선 : 수정/개선 요약 설명
- 사용자 영향도
- SW 지원 영향도
- 노트
- 면책 조항
- 연락처

3) 추가 버전 작성 시 고려사항
- 모든 수정된 내용을 담아 노트 작성
- 자체 기능 향상과는 다른 별도의 릴리즈 버전 출시하고 릴리즈 노트 작성

4) 릴리즈 노트 작성 순서
- 모듈 식별 -> 릴리즈 정보 확인 -> 릴리즈 노트 개요 작성 -> 영향도 체크 -> 정식 릴리즈 노트 작성 -> 추가 개선 항목 식별




디지털 저작권(DRM : Digital Right Management) 관리
- 디지털 콘텐츠 관리 및 보호 기술

1) DRM의 흐름
- 콘텐츠 제공자(Contents Provider) : 콘텐츠 제공
- 콘텐츠 제공자(Contents Divider) : 콘텐츠 유통
- 콘텐츠 제공자(Contents Customer) : 구매해서 사용하는 주체
- Packager : 배포 가능한 형태로 묶어 암호화 하는 프로그램
- Clearing House : 사용 권한, 라이선스 발급, 결제관리
- DRM Controller : 이용 권한 통제
- Security Container : 전자적 보안 장치

2) DRM 기술 요소
- Encryption : 암호화하고 전자서명
- Key Management : 암호화한 키에 대한 저장 및 분배
- Indentification : 식별 체계 표현
- Right Expression : 라이선스의 내용 표현
- Packager : 암호화된 콘텐츠로 생성
- Policy Management : 정책 표현 및 관리
- Tamper Resistance : 크랙 방지
- Authentication : 사용자 인증 기술



형상 관리
1) SCM : Software Configuration Management
- 개발 과정에서 소프트웨어의 변경 사항을 관리
- 개발의 전 단계에 적용되는 활동

2) 중요성
- 변경 사항 체계적으로 추적하고 통제
- 무절제한 변경 방지

3) 기능
- 구분하여 수정 및 추적 용이
- 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구 검토
- 감사 : 베이스 라인의 무결성을 평가
- 기록(상태 보고) : 작업의 결과 기록, 관리하고 보고서 작성
- 버전 제어

4) 소프트웨어 버전 등록 관련 주요 용어
Repository
Import
Check-Out
Check-In
Commit
Update

5) 소프트웨어 버전 등록 과정
 Import -> Check-Out -> Commit -> Update -> Diff

6) 제품 소프트웨어의 형상 관리 역할
- 배포본 관리에 유용
- 소스 수정 제한
- 여러 개발자 동시 개발 가능



버전 관리 도구
1) 공유 폴더 방식
- 로컬 컴퓨터의 공유 폴더에 저장되어 관리
- 약속된 공유 폴더
- 공유 폴더의 파일을 자기 PC로 복사해 컴파일 한 후 이상 유무 확인
- ex) SCCS, RCS, PVCS, QVCS

2) 클라이언트/서버 방식
- 서버에서 저장되어 관리
- 개발자 별로 자신의 PC(클라이언트)로 복사해 작업 후 다시 서버에 반영
- 모든 버전 관리는 서버에서 수행
- 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리작업은 중단
- ex) CVS, SVN(Subversion)

3) 분산 저장소 방식
- 하나의 원격 저장소, 개발자 PC의 로컬 저장소
- 자신의 로컬 저장소로 복사해 작업 후 로컬에서 우선반영(Commit) 후 원격 저장소에 반영(Push)
- 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
- 로컬 저장소에서 작업 수행 -> 처리 속도 빠름
- ex) Git, Bitkeeper

4) SVN(Subversion)
- CVS를 개선
- 2000년 아파치 소프트웨어 재단
- Commit할 때마다 Revision이 1씩 증가
- 서버는 주로 유닉스 사용
- 오픈 소스로 무료 사용 가능
- CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능
-- add
-- commit
-- update
-- checkout
-- lock/unlock
-- import
-- export
-- info
-- diff
-- merge

5) Git
- 원격 : 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
- 로컬 : 개발자들이 본인의 실제 개발을 진행하는 장소
- Branch : 다양한 형태의 기능 테스팅 가능
- Snapshot : 버전의 흐름 파악 가능
-- add
-- commit
-- branch
-- checkout
-- merge
-- init
-- remote add
-- push
-- fetch
-- clone
-- fork



어플리케이션 테스트
1) 개념
결함을 찾아내는 일련의 행위
확인(Validation)
검증(Verification)

2) 기본 원리
완벽한 테스팅 X
결함은 무조건 존재
결함에 집중
개발 초기에 테스팅
살충제 패러독스 : 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
정황 의존적 : 성격에 맞게 테스트
요류 - 부재의 궤변 : 요구사항 충족 필수



어플리케이션 테스트의 분류
1) 프로그램 실행 여부에 따른 테스트
- 정적 테스트 : 프로그램을 실행하지 않고 진행, 명세서나 소스 코드를 대상으로
-- ex) 워크 스루, 인스펙션, 코드 검사
- 동적 테스트 : 프로그램 실행하여 진행
-- ex) 화이트박스 테스트, 블랙박스 테스트

2) 테스트 기반에 따른 테스트
- 명세 기반 테스트 : 명세를 빠짐없이 테스트 케이스로 만들어 테스트
-- ex) 동등 분할, 경계값 분석 (블랙박스 테스트)
- 구조 기반 테스트 : 내보의 논리 흐름
-- ex) 구문 기반, 결정 기반, 조건 기반(화이트박스 테스트)
- 경험 기반 테스트 : 테스터의 경험을 기반
-- ex) 에러 추정, 체크 리스트, 담색적 테스팅

3) 시각에 따른 테스트
- 검증(Verification) 테스트 : 개발자 시각
-- ex) 단위 테스트, 통합 테스트, 시스템 테스트
- 확인(Validation) 테스트 : 사용자 시각
-- ex) 인수 테스트(알파 테스트 ,베타 테스트)

4) 목적에 따른 테스트
- 회복(Recovery) 테스트 : 일부러 결함을 주고, 복구 되는지 확인
- 안전(Security) 테스트 : 불법적인 침입으로 부터 보호할 수 있는 지 확인
- 강도(Stress) 테스트 : 과부하 시에도 정상 실행되는지 확인
- 성능(Performance) 테스트 : 효율성 진단
- 구조(Structure) 테스트 : 내부의 논리적인 경로, 소스 코드의 복잡도 평가
- 회귀(Regression) 테스트 : 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
- 병행(Parallel) 테스트 : 동일한 데이터 입력하여 결과 비교

5) 테스트 커버리지 유형
- 구문 : 모든 문장을 최소 한번 이상 실행
- 결정 : 전체 조건식 최소한 하나의 불린값을 가지도록 측정
- 조건 : 개별 조건식이 최소한 하나의 불린값을 가지도록 조합
- 조건/결정 : 전체조건식과 개별 조건식 모두 불린값을 가지도록 조합
- 변경/조건 결정 : 개별 조건식끼리 영향 X, 전체 조건식의 결과에 독립적으로 영향
- 다중 조건 : 가능한 모든 조합을 100% 보장



화이트박스, 블랙박스
1) White Box Test
모듈 안 내용 직접 볼 수 있음
내부의 논리적인 모든 경로를 테스트
소스코드의 모든 문장을 한번 이상 수행
논리적 경로 점검
- Base Path Testing : 대표적인 화이트박스 테스트 기법
- 제어 구조 검사
-- Condition Testing : 논리적 조건을 테스트
-- Loop Testing : 반복 구조에 맞춰서 테스트
-- Data Flow Testing : 변수의 정의와 변수 사용의 위치에 초점

2) Black Box Test
모듈 안 내용 확인 불가
특정 기능의 작동을 입증하는 테스트 == 기능 테스트
소프트웨어 인터페이스에서 실시
- 동치 분할 검사 (Equivalence Partitioning Testing) : 입력 조건에 타당한 입력자료와 타당하지 않은 자료의 개수를 동등하게 -> 입력 자료에 맞는 결과 출력 확인 (동등 분할 기법)
- 경계값 분석 (Boundary value Analysis) : 경계값에서 오류가 발생활 확률이 높음 -> 입력 조건의 경계값 을 테스트 케이스로 선정
- 원인-효과 그래프 검사 (Cause-Effect Graphing Testing) : 입력 데이터 간의 관계와 출력 상황을 분석한 다음 효용성이 높은 테스트 케이스 선정
- 비교 검사 (Comparison Testing) : 동일한 테스트 자료 제공 -> 동일 결과 출력 확인
- 오류 예측 검사 (Error Guessing) : 다른 기법으로 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법 (데이터 확인 검사)



개발 단계에 따른 애플리케이션 테스트
1) Unit Test
최소 단위인 모듈이나 컴포넌트에 초점
요구사항 기반의 기능성 테스트
주로 구조 기반 테스트를 시행
2) Integration Test (통합 테스트)
단위 테스트 완료된 모듈 결합하는 과정에서의 테스트
모듈 간 또는 통합된 컴포넌트 간의 상호작용 오류 검사
- ex) 빅뱅 테스트, 상향식 테스트(Cluster, Driver) ,하향식 테스트(Stub)
3) System Test
컴퓨터 시스템에서 완벽하게 수행되는가를 점검
화이트 박스(비기능적 요구사항), 블랙박스(기능적 요구사항) 구분
실제 환경과 유사하게 만든 테스트 환경에서 수행
4) Acceptance Test(인수 테스트)
사용자의 요구사항을 충족하는지에 중점
- 알파 : 통제된 환경에서 사용자가 개발자와 함께
- 베타 : 통제되지 않은 환경에서 여러명의 사용자가 행함




통합 테스트
1) 상향식 통합 테스트 (Bottom Up Integration Test)
하위에서 상위 모듈 방향으로 통합하면서 테스트
클러스터(= 하나의 주요 제어 모듈 + 관련 종속 모듈 그룹) 필요
- 하위모듈 클러스터로 결합 -> 더미 모듈인 드라이버 작성 -> 클러스터 단위로 테스트 -> 테스트 완료 후 클러스터는 상위 결합, 드라이버는 실제 모듈로 대체
2) 하향식 통합 테스트 (Top Down Intgeration Test)
상위에서 하위 모듈방향으로 통합하면서 테스트
깊이 우선 통합법, 넓이 우선 통합법 사용
테스트 초기부터 사용자에게 시스템 구조 보여줄 수 있음
상위 모듈에서는 테스트 케이스 사용하기 어려움
- 주요 제어 모듈의 종속 모듈은 Stub으로 대체 -> 깊이 우선 또는 넓은 수너등의 통합 방식에 따라 한번에 하나씩 실제 모듈로 교체 -> 모듈이 통합될 때마다 테스트 실시 -> 회귀 테스트 실시
3) 혼합식 통합 테스트
하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합 -> 최적의 테스트 지원
센드위치식 통합 테스트 방법



테스트 | 테스트 시나리오 | 테스트 오라클 | 테스트 하네스
1) Test Case
설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
명세 기반 테스트(블랙박스 테스트)의 설계 산출물에 해당
미리 설계해두면 테스트 오류 방지 및 테스트 수행 자원의 낭비를 줄일 수 있음

2) Test Scenario
여러 개의 테스트 케이스들을 묶은 집합
구체적인 절차를 명세한 문서
- 유의사항 : 여러개의 시나리오로 분리해 작성

3) Test Oracle
사전에 정의된 참 값을 대입해 비교
- 특징 :
-- 제한된 검증 : 모든 테스트 케이스에 적용할 수 없음
-- 수학적 기법 : 값을 수학적 기법을 이용해 구할 수 있음
-- 자동화 기능 : 프로그램 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있음
- 종류 :
-- 참(True) : 모든 테스트 케이스의 입력 값
-- 샘플링(Sampling) : 특정 몇몇 테스트 케이스의 입력 값들에 대해서만 결과 제공
-- 휴리스틱(Heuristic) : 샘플링 + 나머지 입력값들에 대해서는 추정으로 처리, 샘플링 개선버전
-- 일관성(Consistent) : 수행 전과 후의 결과값이 동일한지 확인

4) Test Harness
구성요소 :
- Test Driver : 하위 모듈 호출
- Test Stub : 상위 모듈을 대신하는 제어모듈의 기능 수행
- Test Suites : 테스트 케이스의 집합
- Test Case : 입력값, 실행 조건, 기대 결과 드응로 만들어진 테스트 항목 명세서
- Test Script : 테스트 실행 절차에 대한 명세서
- Mock Object : 행위를 조건부로 입력 -> 예정된 행위 수행




결함 관리
1) 추적
결함 분포 : 결함 수 측정
결함 추세 : 진행 시간에 따른 결함 수
결함 에이징 (Fault Aging): 결함 상태로 지속되는 시간 측정
2) 결함 추적 순서
등록(Open) -> 검토(Reviewed) -> 할당(Assigned) -> 수정(Resolved) -> 조치 보류(Deferred) -> 종료 (Closed) -> 해제(Clarified)
3) 심각도, 우선순위
심각도 : Critical(치명적) > Major(주요) > Normal(보통) > Minor(경미) > Simple(단순)
우선순위 : Critical(치명적) > High(높음) > Medium(보통) > Low(낮음)



어플리케이션 성능 분석
1) 성능
처리량(Throughput) : 애플리케이션이 처리하는 일의 양
응답 시간(Response Time) : 요청을 전달한 시간부터 응답이 도착할 때까지
경과 시간(Turn Around Time) : 작업을 의뢰한 시간부터 처리가 완료될 때까지
자원 사용률(Resource Usage) : 자원 사용률

2) 애플리케이션 성능 저하 원인 분석
DB에 필요 이상의 많은 데이터를 요청한 경우
커낵션 풀의 크기를 너무 작거나 크게 설정한 경우
JDBC나 ODBC와 같은 미들웨어 사용후 종료하지 않아 연결 누수가 발생한 경우
대량의 파일을 업로드하거나 다운로드해 처리 시간이 길어진 경우

3) 소스 코드 최적화
Clean Code 작성 원칙 : 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

4) 소스 코드 품질분석 도구의 종류
정적 : pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna
동적 : Avalanche, Valgrind



모듈 연계
1) EAI(Enterprise Application Integration)
정보전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
- 포인트 투 포인트(Point to Point) : 점 대 점 연결
- 허브 앤 스포크(Hub & Spoke) : 중앙 집중형, 허브 장애 발생시 시스템 전체에 영향
- 메시지 버스 (Message Bus, ESB 방식) : 어플리케이션 사이에 미들웨어를 둠 -> 확장성 증가, 대용량 처리 가능
- 하이브리드(Hybrid) : Hub & Spoke(그룹 내)와 Message Bus(그룹 간)의 혼합 방식

2) ESB(Enterprise Service Bus)
표준기반의 인터페이스 제공 솔루션
서비스 중신의 통합 지향
결합도(Coupling)를 약하게(Loosely) 유지
관리 및 보안유지 용이
높은 수준의 품질 지원 가능




인터페이스 구현/보안
1) 데이터 통신을 이용한 인터페이스 구현
Parsing
주로 JSON이나 XML 형식의 데이터 포맷으로 인터페이스 구현
* JSON(JavaScript Object Notation) : 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 객체, 개방형 표준 포맷
* XML(eXtensible Markup Language) : HTML과 SGML(Standard Generalized Markup Language)의 복잡함을 해결하기 위해 개발

2) 인터페이스 엔터티를 이용한 인터페이스 구현
시스템 사이에 별도의 인터페이스 엔티티로 상호 연계
일반적으로 인터페이스 테이블을 활용
송, 수신 인터페이스 테이블의 구조는 상황에 따라 서로 다르게 설계 가능

3) 인터페이스 보안 기능 적용
Network, Application, Database
Sniffing : 중간에서 남의 패킷 정보를 도청
소프트웨어 개발 보안(Secure Coding) : 개발 과정에서 지켜야 할 일련의 보안 활동
- ex) 입력 데이터 검증 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용



인터페이스 구현검증/오류확인
1) 인터페이스 구현 검증 도구
xUnit : 다양한 언어 지원 (Java(Junit), C++(Cppunit), .Net(Nunit)), 단위 테스트 프레임워크
STAF : 컴포넌트 재사용, 서비스 호출 등의 기능 지원
FitNesse : 웹 기반 테스트 케이스 설계, 실행, 결과 확인
NTAF : STAF의 장점인 재사용 및 확장성과 FitNesse의 장점인 협업기능을 통합한 NHN(Naver)의 자동화 프레임워크
Selenium : 다양한 브라우저 및 개발언어 지원, 웹 어플리케이션 테스트 프레임워크
watir : Ruby 언어 사용

2) 인터페이스 오류 발생 즉시 확인
- 오류 메시지 알람 표시, 오류 SMS 발송, 오류 내역 이메일 발송

3) 인터페이스 오류 발생 주기적인 확인
오류 로그 확인 : 자세한 오류 원인 및 내역 확인 가능
오류 테이블 확인 : 확인이 쉬워 관리가 용이, 구체적이지 않아 별도의 분석 필요
감시(APM) 도구 사용 : Scouter나 Jennifer 등의 도구로 주기적 확인




추가
1)트리  순회 방법
전위 순회(Pre-Order Traversal) : Root -> Left -> Right
중위 순회(In-Order Traversal) : Left -> Root -> Right
후위 순회(Post-Order Traversal) : Left -> Right -> Root
2) 이진 트리
차수(Degree)가 2이하인 노드 + 자식이 둘 이하로 구성
3) 논리 데이터 저장소
개체(Entity) : 관리할 대상이 되는 실체
속성(Attribute) : 관리할 정보의 구체적 항목
관계(Relationship) : 개체 간의 대응 관계
4) 물리 데이터 저장소
논리 데이터 저장소에서 물리 데이터 저장소 모델로 변환하는 절차
- 단위 개체를 테이블로 변환 -> 속성을 컬럼으로 변환 -> UID(Unique Identifier)를 기본키로 변환 -> 관계를 외래키로 변환 -> 컬럼 유형과 길의 정의 -> 반 정규화 수행 (De-normalization)
5) Index
분포도(Selectivity) 10~15% 이내
- 인덱스 컬럼 선정
수정이 빈번하지 않는 "컬럼"
ORDER BY, GROUP BY, UNION이 빈번한 "컬럼"
분포도가 좋은 컬럼은 단독 인덱스로 생성
인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
- 설계시 고려사항
지나치게 많은 인덱스는 Overhead 발생
인덱스만의 추가적인 저장 공간 필요
넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드 발생
6) View
기본 테이블로부터 유도된 가상 테이블 (기본 테이블과 구조 동일, 조작 동일)
물리적으로 구현되어 있지 않으나 사용자에게는 있는 것 처럼 간주
논리적 족립성 제공
정의된 뷰로 다른 뷰 정의 가능
뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그를 기초로 정의된 다른 뷰도 자동 삭제
- REPLACE : 이미 존재하는 경우 재생성
- FORCE : 본 테이블 존재 여부에 관계 없이 뷰 생성
- NOFORCE : 기본 테이블이 존재할 때만 뷰 생성
- WITH CHECK OPTION : 서브 쿼리 내의 조건을 만족하는 행만 변경
- WITH READ ONLY : DML 작업 불가
장점 : 논리적 데이터 독립성, 자동 보안 제공
단점 : 독립적인 인덱스를 가질 수 없음, 뷰의 정의를 ALTER로 변경 불가능 -> DROP하고 새로 CREATE해야 함, 삽입, 삭제, 갱신, 연산에 제약이 따름

7) Cluster
인덱스의 단점을 해결한 기법 -> 분포도가 넓을수록 오히려 유리
테이블(= 분포도 넓음)의 저장 공간 절약 가능
대량 범위를 조회하는 경우 사용
넓은 분포도에 활용
- 클러스터 테이블 선정
수정이 빈번하지 않는 "테이블"
ORDER BY, GROUP BY, UNION이 빈번한 "테이블"
처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링
조인이 많아 문제가 발생하는 경우는 다중 테이블 클러스터링
- 설계 식 고려사항
조회 속도 향상 + 입력, 수정, 삭제 시 성능 저하 (부하 증가)

8) Partition
Range Partitioning : 지정한 열의 값을 기준으로 분할 ex) 일별, 월별, 분기별 등
Hash Partitioning : 해시 함수에 따라 데이터 분할
List Partitioning : 미리 정해진 그룹핑 기준에 따라 분할
Composite Partitioning : 범위분할 이후 해시함수 적용
장점 : 성능 향상, 가용성 향상, 백업 가능, 경합 감소

9) PL/SQL
Declare : 실행부에서 참조할 모든 변수, 상수, CURSOR, EXCEPTION 선언
Begin/End : BEGIN과 END 사이에 기술디는 영역, 데이터를 처리할 SQL 문과 PL/SQL 블록 기술
Exception : 실행부에서 에러가 발생했을 때 문장 기술
장점 : 컴파일 불필요, 모듈화 기능, 절차적 언어 사용, 에러 처리
저장형 객체 활용 : 저장된 프로시저, 저장된 함수, 저장된 패키지, 트리거

10) 단위 모듈 구현의 원리
Information Hiding : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐
Devide & Conquer : 복잡한 문제를 분해, 모듈 단위로 문제 해결
Data Abstraction : 각 모듈 자료 구조를 액세스하고 수정하는 함수 내에 자료 구조의 표현 내역을 은폐
Module Inpendency : 낮은 결합도와 높은 응집도

11) 알고리즘 설계 기법
Divide and Conquer : 문제를 최소 단위까지 나누고 다시 병합해서 답을 얻음
Dynamic Programming : 과거에 구한 해 활용
Greedy : 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택
Backtracking : 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후  다른 자손 노드 검색

12) 시간 복잡도에 따른 알고리즘
O(1) : 상수형 복잡도 ex) Hash Function
O(logN) : 로그형 복잡도 ex) Binary Search
O(n) : 선형 복잡도 ex) Sequential Search
O(nlogN) : 선형 로그형 복잡도 ex) Quick Sort, Merge Sort
O(N^2) 제곱형 주요 처리 루프 구조가 2중인 경우 ex) Select Sort, Bubble Sort, Insert Sort

13) SQ 품질 측정을 위해 개발자 관점에서 고려해야 할 항목
- 정확성, 무결성, 사용성(O) / 간결성(X)

14) 인터페이스 보안을 위해 네트워크 영역에 적용되는 솔루션
- IPSec, SSL, S-HTTP

15) Alien Code
- 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램

16) IPC(Inter-Process Communication)
대표적인 프로그래밍 인터페이스 집합, 프로세스 간 통신까지 구현 가능
- 대표적인 메소드
Shared Memory : 공유 가능한 메모리 구성
Socket : 네트워크 소켓 이용
Semaphores : 접근 제어
Pipes & Named Pipes : FIFO 형태로 구성된 메모리, 한번에 하나의 프로세스만 접근 가능
Message Queueing : 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신 수행

17) 소프트웨어 재공학이 소프트웨어 재개발에 비해 갖는 장점
위험부담 감소, 비용 절감, 시스템 명세의 오류 억제, 개발시간의 감소

18) 소프트웨어 품질 목표
- 소프트웨어 운영 특성
정확성 (Correctness)
신뢰성 (Reliability)
효율성 (Effeciency)
무결정 (Integrity)
사용 용이성 (Usability)
- 소프트웨어 변경 수용 능력
유지보수성 (Maintainability)
유연성 (Flexibility)
시험 역량 (Testability)
- 소프트웨어 적용 능력
이식성 (Portability)
재사용성 (Reusability)
상호 운용성 (Interoperability)

19) 소프트웨어 공학의 기본 원칙
품질 높은 소프트웨어 상품 개발
지속적인 검증 시행
결과에 대한 명확한 기록 유지

20) AJAX(Asynchronous JavaScript and XML)
JavaScript 비동기 통신기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술

21) Schema
External Schema : 사용자의 관점, 전체 데이터베이스의 일부 (= Sub Schema)
Iternal Schema : 저장장치의 입장, 데이터베이스 전체가 저장되는 방법 -> 단 하나만 존재 가능
Conceptual Schema : 조직 전체의 데이터베이스 -> 단 하나만 존재 가능

22) Hashing Function
폴딩법 : 레코드 키를 여러부분으로 나눔 -> 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용
제산법 : 해시표의 크기보다 큰 수 중에서 가장 작은 소수로 나눈 나머지를 홈 주소로 삼는 방식
기수변환법 : 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수를 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
숫자분석법(계수분석법) : 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
