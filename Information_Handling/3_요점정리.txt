데이터베이스 설계
1) 고려사항
- 무결성, 일관성, 회복, 보안, 효율성, 확장

2) 순서
요구 조건 분석 : 명세서 작성
개념적 설계 (정보 모델링, 개념화) : 독립적인 개념 스키마 모델링, 트랜잭션 모델링
- ex) E-R 다이어그램 모델
논리적 설계 (데이터 모델링) : 목표에 맞는 종속적인 논리 스키마 설계
- ex) 트랜잭션 인터페이스 설계, 테이블 설계(RDB), 논리적 데이터 베이스 구조로 매핑. 스키마의 평가 및 정제
물리적 설계 (데이터 구조화) : 물리적 구조의 데이터로 변환
- ex) 저장 레코드, 접근 경로 설계
구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성



데이터 모델
1) 구성 요소
개체(Entity) : 사람이 생각하는 개념이나 정보 단위
속성(Attribute) : 데이터의 가장 작은 논리적 단위, 데이터 항목 또는 데이터 필드에 해당
관계(Relationship) : 개체 간의 관계

2) 개념적 데이터 모델
추상적 개념으로 표현하는 과정
- ex) E-R(Entity-Relation)

3) 논리적 데이터 모델
컴퓨터 세계의 환경에 맞도록 변환하는 과정
- ex) 관계 모델, 계층 모델, 네트워크 모델

4) 데이터 모델에 표시할 요소
구조(Structure) : 데이터 구조 및 정적 성질을 표현
연산(Operation) : 처리하는 작업에 대한 명세, 조작하는 기본 도구
제약 조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건



개체(Entity)
1) 개체의 정의 및 특징
실세계에 독립적으로 존재하는 유형, 무형의 정보
사람이 생각하는 개념이나 정보 단위
그 자체로서도 구별 가능
유일한 식별자(Unique Identifier)에 의해 식별 가능
다른 개체와 하나 이상의 관계(Relationship)가 있음

2) 개체 선정 방법
담당자와 인터뷰
장부와 전표 이용
DFD를 통해 업무 분석 했을 경우 Data Store 이용
BPR(Business Process Reengineering; 업무프로세스 재설계)에 의해 재정의한 경우 관련 개체 찾음

3) 개체명 지정 방법
업무에서 사용하는 용어로 지정
약어 사용 지양
단수 명사 사용
유일한 객체명
객체 의미에 따른 명명




속성(Attribute)

1) 정의 및 특징
DB의 가장 작은 논리적 단위
데이터 항목 또는 데이터 필드
구성하는 항목 및 특성 기술
- cf) 튜플(Tuple)의 수는 카디널리티(Cardinality)

2) 특성에 따른 분류
기본 속성(Basic Attribute) : 업무 분석을 통해 정의한 속성 ex) 자동차명, 제조일, 연비
설계 속성(Designed Attribute) : 원래 업무상 존재하지 않고 설계 과정에서 도출해낸 속성 ex) 자동차 코드
파생 속성(Derived Attribute) : 다른 속성으로부터 영향을 받아 발생하는 속성 ex) 계산 값

3) 개체 구성 방식에 따른 분류
기본 키 속성(Primary Key Attribute) : 개체를 식별할 수 있는 속성
외래 키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성
일반 속성 : 개체에 포함되어 있고 기본 키, 외래 키에 포함되지 않은 속성

4) 명명 원칙
업무 사용 용어 지정
서술형 금지
약어 사용 지양
개체명은 속성명으로 사용할 수 없음
유일 식별명 지정




관계(Relationship)

1) 형태
one-to-one (1:1) 
one-to-many (1:N)
many-to-many (N:M)

2) 종류
Dependant, Redundant, Recursive, Exclusive




식별자(Identifier)

인스턴스를 유일하게 구분할 수 있는 구분자
모든 객체는 한 개 이상의 식별자가 반드시 필요

1) 대표성 여부
주 식별자(Primary Identifier) : 하나의 개체에 한 개만 존재
보조 식별자(Alternate Identifier) : 하나의 개체에 한 개 이상이 존재

2) 스스로 생성 여부
내부 식별자(Internal Identifier) : 개체 내에서 스스로 만들어지는 식별자
외부 식별자(Foreign Identifier) : 외부 개체의 식별자를 가져와 사용하는 식별자, 자신의 개체에서 다른 개체를 찾아가는 연결자 역할

3) 단일 속성 여부
단일 식별자(Single Identifier) : 주 식별자가 하나의 속성으로만 구성
복합 식별자(Composite Identifier) : 주 식별자가 두 개 이상의 속성으로 구성

4) 대체 여부
원조 식별자(Original Identifier) : 가공되지 않은 원래의 식별자(본질 식별자)
대리 식별자(Surrogate Identifier) : 하나의 속성으로 묶어 사용하는 식별자(인조 식별자)




E-R(개체-관계) 모델

1) 개요
개념적 데이터 모델의 대표
1976년 피터 첸
개체, 속성, 관계로 묘사
관계유형(1:1, 1:N, N:N) 관계 없이 묘사 가능

2) 피터 첸 표기법
사각형 : Entity Type
마름모 : Relationship Type
타원 : Attribute
밑줄 타원 : Primary Key Attribute
복수 타원 : 복합 속성
관계 : 1:1, 1:N, N:M 등의 개체 관계에 대해 대응 수 기술
선, 링크 : 개체 타입과 속성 연결
이중 타원 : 다중 값 속성(복합 속성)

3) 정보공학 표기법 (Information Engineering Notation, 크로우즈 핏)
 1981, Clive Finkelstein & James Martin 공동 개발
| : 필수 (Mandatory)
O : 선택적 (Optional)
< : 다중 (Multiple)
실선은 1개, 까마귀 발은 1개 의미
원형 표시는 선택적 의미, 관계가 있을수도 없을수도 있다.

4) 바커 표기법(Barker Notation)
Richard Barker
----- : 필수(Mandatory)
- - - - : 선택적(Optional)
< : 다중 (Multiple)





관계형 데이터 모델
1) 개요
표를 이용해 데이터 상호관계를 정의하는  DB 구조
Primary Key와 Foreign Key로 데이터 간의 관계 표현
관계형 모델의 대표적 언어 : SQL
1:1, 1:N, N:M의 관계를 자유롭게 표현

2) Relation 구조
- Tuple, Row, Record
속성의 모임으로 구성
파일 구조상 레코드(실제 데이터)와 같은 의미
튜플의 수 = Cardinality 또는 기수, 대응수

- Attribute, Column, Field
가장 작은 논리적 단위
데이터 항목 또는 데이터 필드
개체의 특성을 기술
속성의 수 = Degree(차수)

- Domain
하나의 Attribute가 가질 수 있는 원자(Atomic) 값들의 집합

3) 릴레이션의 특징
튜플(행)들은 모두 상이함, 서로 다른 값을 가짐
튜플(행) 사이에는 순서가 없음
애트리뷰트(열) 간의 순서는 중요하지 않음
각 애트리뷰트는 식별을 위해 릴레이션 내에서 유일한 이름을 가짐
애트리뷰트는 원자값으로 저장

- 정리
1. 튜플 : 상이한 값, 순서 X
2. 애트리뷰트 : 원자 값, 순서 중요 X, 유일한 이름





키
튜플을 구분할 수 있는 기준이 되는 속성

1) 후보키(Candidate Key)
속성들의 부분 집합, 반드시 하나 이상의 후보키 존재
유일성과 최소성을 만족
- 유일성(Unique) : 하나의 키 값으로 하나의 튜플만 식별 가능
- 최소성(Minimality) : 꼭 필요한 속성으로만 구성

2) 기본키(Primary Key)
중복된 값과 NULL 값을 가질 수 없음
유일성과 최소성 만족

3) 대체키(Alternate Key)
기본키를 제외한 나머지 후보키

4) 슈퍼키(Super Key)
속성들의 집합
유일성은 만족, 최소성은 만족 X

5) 외래키(Foreign Key)
다른 릴레이션의 기본키를 참조
릴레이션 간의 참조 관계 표현




무결성(Integrity)
데이터와 현실의 실제 값이 일치하는 정확성 의미

1) 개체 무결성 (Entity Integrity, 실체 무결성)
어떤 속성도 널 값이나 중복 값을 가질 수 없음
속성 값이 널 값이 아닌 원자 값을 갖는 성질

2) 도메인 무결성 (Domain Integrity, 영역 무결성)
도메인에 지정된 값 만을 가져야 함

3) 참조 무결성(Referential Integrity)
외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일
릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다

4) 사용자 정의 무결성(User-Defined Integrity)
사용자가 정의한 제약 조건 만족

5) 데이터 무결성 강화
어플리케이션 : 무결성 조건 검증 코드를 프로그램 내에 추가
데이터베이스 트리거 : 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL 추가
제약 조건 : DB에 제약 조건 설정해 무결성 유지




관계대수 및 관계 해석
1) 관계 대수
'어떻게 유도하는가'를 기술하는 절차적 언어
- 순수관계 연산자
Select(선택) : 조건(Predicate)을 만족하는 튜플들의 부분 집합 (수평 연산)
Project(추출) : 속성들의 부분 집합, 중복은 제거됨 (수직 연산)
Join(조인) : 두개의 릴레이션이 공통으로 가지고 있는 속성으로 두개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 (연관된 튜플들을 결합)
Division(나누기) : (R/S) = S 릴레이션의 도메인 값과 일치하는 R 릴레이션의 튜플들을 찾아내는 연산

-일반집합 연산자
Union(합집합) : 두 릴레이션의 합이 추출, 중복은 제거
Intersection(교집합) : 두 릴레이션의 중복 값만 추출
Difference(차집합) : 두 릴레이션의 중복되지 않는 값만 추출
Cartesian Product(교차곱) : 두 릴레이션의 간으한 모든 튜플들의 집합

2) 관계해석(Relational Calculus)
수학의 Predicate Calculus(술어 해석)에 기반
원하는 정보가 무엇이라는 것만 정의하는 '비절차적 특성'
튜플 관계해석, 도메인 관계해석
관계 해석과 관계 대수는 처리하는 기능과 능력 면에서 동등
관계 대수로 표현한 식은 관계 해석으로 표현 가능
-연산자
OR 연산
AND 연산
NOT 연산
-정량자
전칭 정령자(Universal Qunatifier) : 모든 가능한 튜플
존재 정량자(Existential Quantifier) : 어떤 튜플 하나라도 존재

3) 관계대수와 관계해석 비교
특징 : 절차적 언어(순서 명시) | 비 절차적 언어 (계산 수식의 유연적 사용), Predicate Calculus 기반
목적 : 어떻게 유도하는가?(How) | 무엇을 얻을 것인가?(What)
종류 : 순수 관계 연산자, 일반 집합 연산자 | 튜플 관계 해석, 도메인 관계 해석



정규화(Normalization), 반정규화(Denormalization)
하나의 종속성이 하나의 릴레이션에서 표현될 수 있도록 분해하는 과정
DB의 논리적 설계 단계에서 수행

1) 목적
안정성 및 무결성 유지
어떤 릴레이션도 데이터베이스 내에서 표현 가능하게
효과적인 검색 알고리즘 생성 가능
중복 배제해 이상(Anomaly) 발생 방지 및 저장 공간 최소화
개체와 속성의 누락여부 확인 가능
데이터 삽입시 릴레이션 재구성 필요 줄임

2) Anomaly의 개념 및 종류
정규화 X, 불필요하게 중복되어 조작 시 예기지 못하게 오류가 발생하는 현상
- 삽입 이상(Insertion Anomaly) : 의도와 상관없이 원하지 않는 값들도 함께 삽입
- 삭제 이상(Deletion Anomaly) : 의도와는 상관없는 값들도 함께 삭제
- 갱신 이상(Update Anomaly) : 일부 튜플의 정보만 갱신

3) 정규화의 원칙
정보의 무손실, 분리의 원칙, 데이터의 주복성 감소

4) 정규화 과정
1NF(제 1정규형) : 모든 도메인이 원자 값으로만 되어있는 정규형
2NF(제 2정규형) : 완전 함수적 종속을 만족, 부분적 함수 종속을 제거한 정규형
3NF(제 3정규형) : 이행적 함수 종속 관계 (A->B 이고 B->C => A->C)
BCNF(Boyce-Codd 정규형) : 모든 결정자가 후보키인 정규형 (강한 제 3 정규형, 보이드/코드 정규형)
4NF(제 4정규형) : 다치 종속이 성립
5NF(제 5정규형) : 모든 조인 종속이 후보키를 통해서만 성립하는 정규형

5) 반정규화 개념
테이블 통합 : 1:1, 1:N, 슈퍼타입/서브타입
테이블 분할 : 수평 분할, 수직 분할 -> 기본키의 유일성 관리가 어려워짐
중복 테이블 추가 : 집계 테이블, 진행 테이블, 특정 부분만을 포함하는 테이블
중복 속성 추가 : 자주 사용하는 속성을 하나 더 추가하는 것




시스템 카탈로그(System Catalog)
1) 의미
정보를 유지 관리하는 시스템 테이블
== 데이터 사전(Data Dictionary)
저장된 정보 : 메타 데이터(Meta-Data)

2) 특징
일반 이용자도 SQL로 내용을 검색할 수 있음
INSERT, DELETE, UPDATE문으로 카탈로그 '갱신 불가능'

3) Data Directory(사전 관리기)
Data Dictionary에 수록된 데이터에 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
시스템만 접근 가능
cf) Data Dictionary : 사용자와 시스템 모두 접근 가능




데이터베이스 저장 공간 설계
1) Table
행(Row, Tuble), 열(Column, Attribute)로 구성
논리 설계 단계의 Entity에 대응하는 객체

2) Clustered Index Table
기본키나 인덱스키의 순서에 따라 데이터가 저장
일반적인 인덱스 테이블에 비해 접근 경로 단축

3) Partitioning Table
대용량의 테이블을 파티션으로 나눈 테이블
- 레인지 파티셔닝(Range Partitioning) : 지정한 열의 값을 기준으로 분할 (범위 분할)
- 해시 파티셔닝(Hash Partitioning) : 해시 함수에 따라 분할 (해시 분할)
- 리스트 파티셔닝(List Partitioning) : 미리 정해진 그룹핑 기분에 따라 분할
-컴포지트 파티셔닝(Composite Partitioning) : 레인지 파티셔닝 이후 해시함수 적용 (조합 분할) ex) 범위 + 해시 분할

- 파티션의 장점
성능 향상, 가용성 향상, 백업 가능, 경합 감소

4) 외부 테이블(External Table)
일반 테이블처럼 이용할 수 있는 외부 파일
ex) Data Warehouse, ETL(Extraction, Transformation, Loading)

5) 임시 테이블(Temporary Table)
트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
트랜잭션이 종료되면 데이터 삭제됨
절차적 처리를 위해 임시로 사용

6) Column
가변 길이 데이터 타입 : 예상되는 최대 길이로 정의
고정 길이 데이터 타입 : 최소 길이로 지정
소수저 이하 자릿수 : 반올림 되어 저장
고정 길이 컬럼 + NOT NULL인 컬럼 : 앞 쪽
가변 길이 컬럼 + NULL이 많은 것으로 예상되는 컬럼 : 뒤 쪽

7) Tablespace
논리적인 영역
논리적 : Tablespace에 저장
물리적 : Data File에 저장
- 설계 시 고려사항
업무별로 구분해 지정
테이블과 인덱스는 분리해 저장
대용량 테이블은 하나의 테이블 스페이스에 독립적으로 저장함
LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정



Transaction
1) 정의
하나의 논리적인 기능을 수행하기 위한 작업의 단위
모두 함께 수행되어야 할 일련의 연산들
- COMMIT : 트랜젝션 정상적으로 종료 시, 변경 내용 DB반영
- ROLLBACK : 트랜잭션 비정상 종료 시, 작업 쉬소하고 이전 상태로 복구
- SAVEPOINT(=CHECKPOINT) : ROLLBACK 할 위치인 저장점 지정
COMMIT과 ROLLBACK 명령어에 의해 보장받는 트랜잭션 특징 = 원자성

2) 특성
원자성(Atomicity) : 트랜잭션이 DB의 모두에 반영되든지 아니면 전혀 반영되지 않아야 함 (All or Nothing)
일관성(Consistency) : 트랜잭션 완료시 일관성 있는 DB 상태 유지
독립성(Isolation, 격리성) : 둘 이상의 트랜잭션 동시 실행 시 한개의 트랜잭션만 접근 가능
영속성(Durability) : 완료된 트랜잭션 결과는 영구적으로 반영됨

3) CRUD 매트릭스
Create, Read, Update, Delete
C > D > U > R 의 우선순위
테이블에 C, R, U, D 가 모두 없는 경우
테이블에 C 또는 R이 없는 경우(프로세스는 하나만 있어도 돌아감)




Index

1) 개념 및 선정기준, 고려사항
레코드에 빠르게 접근 위해 <키 갑스 포인터> 쌍으로 구성된 데이터 구조

- 인덱스 컬럼 선정
분포도(Selectivity)가 10 ~ 15 % 이내인 '컬럼'
수정이 빈번하지 않는 컬럼
ORDER BY, GROUP BY, UNION 이 빈번한 '컬럼'
분포도가 좋은 컬럼은 단독 인덱스로 생성
인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성

- 고려 사항
추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있음
지나치게 많은 인덱스 => Overhead
넒은 범위 인덱스 처리 시, 오히려 많은 오버헤드
인덱스만의 추가적인 저장 공간 필요
저장 공간 분리되도록 설계

2) 종류
클러스터드 인덱스(Clustered Index) / 넌클러스터드 인덱스(Non-Clustered Index)
트리 기반 인덱스 : 인덱스 저장 블록들이 트리 구조
비트맵 인덱스 : 인덱스 컬럼 데이터를 Bit 값인 0, 1로 변환
함수 기반 인덱스 : 함수나 수식 적용
비트맵 조인 인덱스 : 다수의 조인
도메인 인덱스 : 개발자가 인덱스를 직접 만들어 사용(확장형 인덱스)




분산 데이터베이스 설계
1) 정의
논리적으로는 하나의 시스템, 물리적으로는 네트워크로 연결된 여러 사이트에 분산된 데이터베이스

2) 구성 요소
분산 처리기 : 자체 처리능력 (지리적으로 분산)
분산 데이터베이스 : 지리적으로 분산 -> 해당 지역 특성에 맞게 구성
통신 네트워크 : 분산 처리기들을 통신망으로 연결 -> 논리적으로 하나의 시스템처럼 작동

3) 목표
위치 투명성(Location Transparency) : 실제 위치를 알 필요 없음
중복 투명성(Replication Transparency) : 동일 데이터가 중복 되 있더라도, 사용자는 하나처럼 사용
병행 투명성(Concurrency Transparency) : 다수의 트랜잭션이 동시에 실현되도 결과는 영향 X
분할 투명성(Division Transparency) : 논리적 릴레이션이 여러 단편으로 분할되어 있음을 알 필요 X
장애 투명성(Failure Transparency) : 장애가 발생해도 트랜잭션을 정확하게 처리하고 데이터 무결성 보장

4) 장, 단점
- 장점
지역 자치성이 높음
자료의 공유성 햐상
분산 제어 가능
시스템 성능 향상
중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
신뢰성 및 가용성
점진적 시스템 용량 확장 용이

- 단점
DBMS가 수행할 기능 복잡
데이터베이스 설계 어려움
소프트웨어 개발 비용 증가
처리 비용 증가
잠재적 오류 증가 (사이트 간의 오류 발생률 높음 -> 보안의 어려움)

5) 분산 데이터베이스 설계
어플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적
- 분산 설계 방법
테이블 위치 분산 : 테이블을 각기 다른 서버에 분산하여 배치하는 방법
분할(Fragmentation) : 테이블의 데이터를 분할하여 분산 시키는 것
할당(Allocation) : 동일한 분할을 여러개의 서버에 생성하는 방법 ex) 중복 없는 할당, 중복 있는 할당




데이터베이스 이중화 / 서버 클러스터링
1) 데이터베이스 이중화(Database Replication)
시스템 오류 발생시 복구를 위해 DB를 복제해 관리

2) 이중화 분류
Eager 기법 : 데이터 변경시 DB에 즉시 전달해 내용이 즉시 적용되게 하는 기법
Lazy 기법 : 변경 사실을 새로운 트랜잭션에 작성해 각 데이터 베이스에 전달 -> DB마다 새로운 트랜잭션이 수행되는 것으로 간주

3) 이중화 구성 방법
활동-대기(Active-Standby) : 한 DB가 활동 상태로 서비스 시, 다른 DB 대기 -> 장애 발생 시, 대기 상태의 DB가 모든 서비스 대신 수행 == 구성 방법 및 관리 쉬움
활동-활동(Active-Active) : 두 개의 DB가 서로 다른 서비스 제공 -> 한 쪽에 문제시 다른 DB가 제공 == 처리율이 높지만, 구성 방법 및 설정 복잡

4) Server Clustering
두 대 이상의 서버를 하나처럼 운영하는 기술
고가용성 Clustering : 하나의 서버에 장애 -> 다른 서버가 대신 처리
병렬 처리 Clustering : 하나의 작업을 여러 개의 서버에 분산해 처리



데이터베이스 보안 / 스토리지
1) 보안 개요
권한이 없는 사용자가 액세스 하는 것을 금지
일반적으로 각 객체별 접근 권한을 가짐

2) 암호화(Encryption)
- 암호화 과정
암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
ex) 개인키 암호 방식 (대칭키), 공개키 암호 방식(비대칭키)
- 복호화(Decryption) 과정
암호문을 원래의 평문으로 바꾸는 과정

3) 암호화 방식
- 개인키 암호 방식(Private Key Encryption, 대칭키)
동일한 키로 암호화, 복호화 진행
비밀키는 DB 권한이 있는 사용자만 나눠 가짐
ex) DES, AES, SEED, ARIA

- 공개키 암호 방식(Publuc Key Encryption, 비대칭키)
암호화할 때 사용하는 키(공개키) == DB 사용자에게 공개
복호화할 때의 키(비밀키) == 관리자가 관리
ex) RSA(Rivest Shamir Adleman) Diffie Hellman Algorithm

4) 접근 통제
데이터 객체와 사용자로부터의 정보 흐름 제한
- 3요소
정책, 보안 모델, 메커니즘
- 임의 접근 통제(DAC; Discretionary Access Control)
사용자의 신원에 따라 접근 권한 부여 => 접근 통제 권한 = 주체
- 강제 접근 통제(MAC; Mandatory Access Control)
주체와 객체의 등급 비교해 접근 권한 부여 => 접근 토제 권한 = 제 3자

5) 접근통제 정책
신분 기반 정책(DAC) : 신분에 근거
규칙 기반 정책(MAC) : 권한에 근거
역할 기반 정책(RBAC) : 역할에 근거

6) 접근통제 메커니즘
접근통제 리스트(ACL; Access Control List) : 객체를 기준
능력 리스트(CL; Capability List) : 주체를 기준
보안 등급(Security Label), 패스워드, 암호화

7) 접근통제 보안 모델
- 기밀성
군사적 목적으로 개발
최초의 수학적 모델
기밀성 보장 최우선
ex) 벨라 파듈라 : No Read Up (기밀성), No Write Down
- 무결성
불법적 정보 변경 방지
무결성 기반으로 개발
ex) 비바 : No Read Down, No Write Up (무결성)
- 접근통제
접근 통제 메커니즘을 보안 모델로 발전
ex) Access Control Matrix : 행 = 주체, 열 = 객체

8) 데이터베이스 백업 종류
- 물리 백업
로그 파일 백업 실시 : 완전 복구
로그 파일 백업 없음 : 백업 시점까지 복구
- 논리 백업
DBMS 유틸리티 : 백업 시점까지 복구

9) Storage
- DAS(Direct Attached Storage)
서버와 저장장치를 전용 케이블로 직접 연결하는 방식
설치 및 운영이 쉬움
초기 및 유지보수 비용 저렴
파일 공유 불가, 확장성 및 유연성 떨어짐

- NAS(Network Attached Storage)
서버와 저장장치를 내트워크로 연결
장소에 구애받지 않고 저장장치에 접근 가능
확장성 및 유연성 우수
접속 증가 시 성능 저하

- SAN(Storage Area Network)
서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성
파이버 채널 스위치로 네트워크 구성
광 케이블로 처리속도 빠름
확장성 및 유연성과 가용성 뛰어남
설치 비용이 많이 듦




논리 데이터 모델의 물리 데이터 모델 변환 및 품질 검토
1) 슈퍼/서브타입을 테이블로 변환
서브타입을 슈퍼타입에 통합
슈퍼타입 속성들을 각각의 서브타입에 추가해 서브타입들을 개별적인 테이블로 만드는 것
개별타입 기준 테이블 변환 : 각각의 개별적인 테이블로 변환

2) 물리 데이터 모델 품질 기준 (= 논리 데이터 모델 품질 기준)
정확성 : 요구사항, 업무규칙, 표기법에 따라 정확하게 표현 됨
완전성 : 구성 요소를 누락 없이 정의, 요구사항이나 업무 영역을 누락없이 반영
준거성 : 데이터 표준, 표준화 규칙, 법적 요건 등을 정확하게 준수
최신성 : 최근의 이슈나 현행 시스템을 반영
일관성 : 표현상의 일관성을 유지
활용성 : 업무 변화에 따른 데이터 구조의 변경이 최소화 될 수 있도록 설계됨




SQL 응용
1974, IBM에서 개발한 SEQUEL에서 유래
관계 대수와 관계 해석을 기초로 한 혼합 데이터 언어

1) SQL(Structured Query Language)의 분류
DDL
DML
DCL

2) SELECT
- 일반 함수
WHERE : 검색할 조건
ORDER BY : 정렬
GROUP BY : 그룹화
HAVING : GROUP BY와 함께 사용, 그룹에 대한 조건
DISTINCT : 중복 튜플 제거

- 집계/그룹 함수 : GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수 기술
COUNT(속성명) : 튜플 수
SUM(속성명) : 합계
AVG(속성명) : 평균
MAX(속성명) : 최대값
MIN(속성명) : 최소값
STDDEV(속성명) : 표준편차
VARIANCE(속성명) : 분산
ROLLUP(속성명, 속성명) : 그룹별 소계(하위에서 상위 레벨 순)
CUBE(속성명) : 모든 조합의 그룹별 소계 (상위에서 하위 레벨 순)

-윈도우 함수
GROUP BY 절을 이용하지 않고 속성의 값을 집계할 함수를 기술
함수의 인수로 지정한 속성(== 대상 레코드의 범위) == WINDOW
ex) PARTITION BY : 윈도우 함수가 적용될 범위로 사용할 속성 지정
=> WINDOW 함수 OVER (PARTITION BY 속성 ORDER BY 속성) [AS 바꾸고 싶은 이름]
ROW NUMBER() : WINDOW 별로 각 레코드에 대한 일련번호 반환
RANK() : WINDOW 별로 순위를 반환하며, '공동 순위'를 반영
DENSE_RANK() : WINDOW 별로 순위를 반환하며 '공동 순위를 무시'하고 순위를 부여

3) JOIN
결합을 의미
두 릴레이션으로부터 연관된 튜플을 결합해, 하나의 새로운 릴레이션 반환

-- 논리적 조인
- INNER JOIN : 공동 존재 컬럼 값이 같은 경우를 추출
- NATURAL JOIN : 같은 컬럼 명을 가진 값이 같은 경우를 추출
- CROSS JOIN : 조인 조건이 없는 모든 데이터 조합을 추출

-- 외부 조인
- LEFT OUTER JOIN : 왼쪽의 모든 데이터와 오른쪽의 동일 데이터 추출
- RIGHT OUTER JOIN : 오른쪽의 모든 데이터와 왼쪽의 동을 데이터 추출
- FULL OUTER JOIN : 양쪽의 모든 데이터를 추출

-- 물리적 조인
- NESTED-LOOP JOIN : 다수의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합해 원하는 결과를 조합하는 방식
- SORT-MERGE JOIN : 양쪽의 정렬 결과를 차례로 검색하면서 연결고리 형태로 합병
- HASH JOIN : 해싱 함수 기법을 활용하여 조인 수행


SQL 활용
1) 절차형 SQL
연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
일반적인 프로그래밍 언어에 비해 효율이 떨어짐
연속적인 작업 처리 적합
BEGIN ~ END 형식으로 작성되는 Block 구조로 기능별 모듈화 가능

2) Procedure
미리 저장해 높은 SQL 작업 수행, 한 개 이상의 값 혹은 반환을 아예 하지 않음
일일 마감 작업, 일괄 작업 등에 주로 사용

DECLARE(필수) : 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부
BEGIN(필수) : 프로시저의 시작(실행부)
- CONTROL : 조건문 또는 반복문 삽입 -> 순차적 처리
- SQL : DML, DCL 삽입 (데이터 관리)
- EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리
- TRANSACTION : 수행된 데이터 작업들을 DB에 적용할지 말지 결정하는 처리부
END(필수) : 프로시저의 종료, BEGIN/END




DBMS 접속 기술
1) 웹 응용 시스템의 구조
사용자 <-> 웹 서버 <-> WAS <-> DBMS

2) DBMS 접속 기술
- JDBC(Java Database Connectivity)
1997, 썬 마이크로 시스템에서 출시
Java로 다양한 DB에 접속할 때 사용되는 표준 API
접속하려는 DBMS에 대한 드라이버가 필요

- ODBC(Open Database Connectivity)
1992, 마이크로소프트
DB 접근을 위한 표준 개방형 API
개발 언어에 관계 없이 사용 가능
ODBC의 드라이버 관리자가 해당 DBMS에 맞춰서 연결 (DBMS 종류를 몰라도 됨)

3) 정적 vs 동적
- SQL 구성
'Cursor' vs 'String'
- 개발 패턴
반복문 vs 로직(NVL 함수 없이)
- 실행 속도
빠름 vs 느림
- 사전 검사
가능 vs 불가능 (-> SQL 변형 위험)



ORM (Object-Relational Mapping)
1) 개요
객체와 RDB의 데이터를 연결하는 기술
프로그래밍 코드 또는 DB와 독립적 -> 재사용 및 유지보수 용이
직관적이고 간단하게 데이터 조작 가능

2) 프레임워크
Java : JPA, Hibernate, Eclipse Link, Data Nucleus, Ebean 등
C++ : ODB, OxOrm 등
Python : Django, SQL Alchemy, Storm 등
iOS : Core Date, Database Objects 등
.NET : NHibernate, Database Objects, Dapper 등
PHP : Doctrine, Propel, RedBean 등

3) 한계
자동으로 SQL 작성 -> 수동으로 확인해야 함
프로젝트가 크고 복잡할수록 비효율
호환이 어려움, 일일이 변환작업 거쳐야함